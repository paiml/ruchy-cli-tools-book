// Tests for ruchy-cat
// Demonstrates EXTREME TDD approach
// Sprint 1: RED-GREEN-REFACTOR cycle

// REFACTOR PHASE: Clean, well-documented tests
// Task S1T7: Improved test organization and documentation

// Implementation: read_file function
// Reads file contents and returns as string
fun read_file(path) {
    fs_read(path)
}

// Implementation: cat_files function
// Concatenates multiple files and prints to stdout
fun cat_files(files) {
    if files.len() == 0 {
        println("Reading from stdin not yet implemented")
    } else {
        for file in files {
            let contents = read_file(file)
            print(contents)
        }
    }
}

// ============================================================================
// UNIT TESTS: read_file function
// ============================================================================

@test("reads single file successfully")
fun test_read_single_file() {
    // Setup: Create test file
    let test_file = "test_cat_single.txt"
    let test_content = "Hello, Ruchy!"
    fs_write(test_file, test_content)

    // Exercise: Call read_file function
    let result = read_file(test_file)

    // Verify: Should read file contents
    assert_eq(result, test_content, "Should read file contents")

    // Cleanup
    fs_remove_file(test_file)
}

@test("reads file and preserves newlines")
fun test_preserves_newlines() {
    // Setup
    let test_file = "test_newlines.txt"
    let test_content = "Line 1\nLine 2\nLine 3\n"
    fs_write(test_file, test_content)

    // Exercise
    let result = read_file(test_file)

    // Verify
    assert_eq(result, test_content, "Should preserve newlines")

    // Cleanup
    fs_remove_file(test_file)
}

@test("reads empty file")
fun test_empty_file() {
    // Setup
    let test_file = "test_empty.txt"
    fs_write(test_file, "")

    // Exercise
    let result = read_file(test_file)

    // Verify
    assert_eq(result, "", "Should handle empty files")

    // Cleanup
    fs_remove_file(test_file)
}

@test("reads file with special characters")
fun test_special_characters() {
    // Setup: File with tabs, quotes, special chars
    let test_file = "test_special.txt"
    let test_content = "Tab:\t Quote:\" Newline:\n Unicode:→"
    fs_write(test_file, test_content)

    // Exercise
    let result = read_file(test_file)

    // Verify: Special characters preserved
    assert_eq(result, test_content, "Should preserve special characters")

    // Cleanup
    fs_remove_file(test_file)
}

// ============================================================================
// INTEGRATION TESTS: cat_files function
// ============================================================================

@test("concatenates multiple files in order")
fun test_concatenate_multiple_files() {
    // Setup: Create multiple test files
    let file1 = "test_multi_1.txt"
    let file2 = "test_multi_2.txt"
    let file3 = "test_multi_3.txt"

    fs_write(file1, "First")
    fs_write(file2, "Second")
    fs_write(file3, "Third")

    // Exercise: Read all three files
    let result1 = read_file(file1)
    let result2 = read_file(file2)
    let result3 = read_file(file3)

    // Verify: Each file contains expected content
    assert_eq(result1, "First", "First file should contain 'First'")
    assert_eq(result2, "Second", "Second file should contain 'Second'")
    assert_eq(result3, "Third", "Third file should contain 'Third'")

    // Cleanup
    fs_remove_file(file1)
    fs_remove_file(file2)
    fs_remove_file(file3)
}

@test("handles large file content")
fun test_large_file() {
    // Setup: Create file with repeated content (simulating large file)
    let test_file = "test_large.txt"
    let line = "This is a test line with some content.\n"

    // Build content by repeating line multiple times
    let content = ""
    for i in range(0, 100) {
        content = content + line
    }

    fs_write(test_file, content)

    // Exercise
    let result = read_file(test_file)

    // Verify: Content length is correct
    assert_eq(result.len(), content.len(), "Should read all content")

    // Cleanup
    fs_remove_file(test_file)
}

// ============================================================================
// PROPERTY-BASED TESTS: Invariant verification with 1000+ iterations
// ============================================================================

@test("property idempotent reads - reading same file twice gives same result")
fun property_idempotent() {
    // Setup: Create test file with varied content
    let test_file = "test_property_idempotent.txt"
    let test_content = "Line 1\nLine 2\nSpecial: \t \"quoted\" →\n"
    fs_write(test_file, test_content)

    // Property: Reading the same file multiple times should always give identical results
    let first_read = read_file(test_file)

    // Verify: 1000 iterations of reading should all match first read
    for i in range(0, 1000) {
        let current_read = read_file(test_file)
        assert_eq(current_read, first_read, "Read should be idempotent - iteration " + i.to_string())
    }

    // Cleanup
    fs_remove_file(test_file)
}

@test("property length preservation - content length matches file size")
fun property_length_preservation() {
    // Property: For any content written, reading should preserve exact length

    let test_file = "test_property_length.txt"

    // Test with 100 different file sizes (0 to 5000 bytes)
    for size in range(0, 100) {
        // Generate content of specific size
        let content = ""
        let char = "x"
        for i in range(0, size * 50) {
            content = content + char
        }

        // Write content
        fs_write(test_file, content)

        // Read and verify length preserved
        let result = read_file(test_file)
        assert_eq(result.len(), content.len(),
                 "Length should be preserved for size " + content.len().to_string())
    }

    // Cleanup
    fs_remove_file(test_file)
}

@test("property content preservation - varied content types")
fun property_content_preservation() {
    // Property: Any valid string written should be read back identically

    let test_file = "test_property_content.txt"

    // Test 100 iterations with different content patterns
    for i in range(0, 100) {
        let content = ""

        // Build varied content based on iteration
        if i % 5 == 0 {
            // Empty content
            content = ""
        } else if i % 5 == 1 {
            // Single character
            content = "a"
        } else if i % 5 == 2 {
            // Newlines only
            content = "\n\n\n\n\n"
        } else if i % 5 == 3 {
            // Special characters
            content = "\t\"\'\n→←↑↓"
        } else {
            // Repeated pattern
            let pattern = "Line " + i.to_string() + "\n"
            for j in range(0, 10) {
                content = content + pattern
            }
        }

        // Write and read back
        fs_write(test_file, content)
        let result = read_file(test_file)

        // Verify exact match
        assert_eq(result, content,
                 "Content should be preserved exactly - iteration " + i.to_string())
    }

    // Cleanup
    fs_remove_file(test_file)
}

@test("property multiple file sizes - handles 0 to 10KB")
fun property_file_sizes() {
    // Property: Should handle files of various sizes correctly

    let test_file = "test_property_sizes.txt"

    // Test 50 different file sizes from empty to ~10KB
    for size_factor in range(0, 50) {
        // Generate content: empty, small (10 chars), medium (100 chars), large (1000+ chars)
        let content = ""
        let base_unit = "0123456789"  // 10 characters

        // Build content based on size factor
        for i in range(0, size_factor * 20) {
            content = content + base_unit
        }

        // Write file
        fs_write(test_file, content)

        // Read and verify
        let result = read_file(test_file)
        assert_eq(result.len(), content.len(),
                 "Should handle size " + content.len().to_string() + " bytes")
        assert_eq(result, content,
                 "Content should match for size " + content.len().to_string())
    }

    // Cleanup
    fs_remove_file(test_file)
}
