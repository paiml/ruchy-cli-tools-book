// ruchy-grep tests
// Chapter 2 example from Ruchy CLI Tools Book
// Following EXTREME TDD methodology

// ============================================================================
// STUB IMPLEMENTATION - RED PHASE (S2T1)
// ============================================================================

// Searches for a pattern in a file and returns matching lines.
// GREEN PHASE (S2T2): Minimal implementation
fun grep_in_file(pattern, file_path) {
    let content = fs_read(file_path)
    let matches = ""
    let current_line = ""

    // Parse lines manually (split() not available in test environment)
    for i in range(0, content.len()) {
        let ch = content[i]
        if ch == "\n" {
            if current_line.contains(pattern) {
                matches = matches + current_line + "\n"
            }
            current_line = ""
        } else {
            current_line = current_line + ch
        }
    }

    // Check last line (if no trailing newline)
    if current_line.len() > 0 && current_line.contains(pattern) {
        matches = matches + current_line + "\n"
    }

    matches
}

// Searches for a pattern in a file with case-insensitive matching.
fun grep_in_file_ignore_case(pattern, file_path) {
    let content = fs_read(file_path)
    let matches = ""
    let current_line = ""
    let pattern_lower = pattern.to_lowercase()

    for i in range(0, content.len()) {
        let ch = content[i]
        if ch == "\n" {
            if current_line.to_lowercase().contains(pattern_lower) {
                matches = matches + current_line + "\n"
            }
            current_line = ""
        } else {
            current_line = current_line + ch
        }
    }

    // Check last line
    if current_line.len() > 0 && current_line.to_lowercase().contains(pattern_lower) {
        matches = matches + current_line + "\n"
    }

    matches
}

// ============================================================================
// UNIT TESTS - Basic Functionality
// ============================================================================

@test("finds pattern in single line")
fun test_find_pattern_in_file() {
    // Setup: Create test file with known content
    let test_file = "test_grep_single.txt"
    let test_content = "Hello World\nThis is a test\nPattern matching\nAnother line\n"
    fs_write(test_file, test_content)

    // Exercise: Search for "Pattern" in file
    let result = grep_in_file("Pattern", test_file)

    // Verify: Should return lines containing the pattern
    assert_eq(result, "Pattern matching\n", "Should find line with pattern")

    // Cleanup
    fs_remove_file(test_file)
}

@test("finds multiple matching lines")
fun test_find_multiple_matches() {
    let test_file = "test_grep_multiple.txt"
    let test_content = "apple pie\nbanana split\napple juice\norange\napple crisp\n"
    fs_write(test_file, test_content)

    let result = grep_in_file("apple", test_file)

    assert_eq(result, "apple pie\napple juice\napple crisp\n", "Should find all lines with pattern")

    fs_remove_file(test_file)
}

@test("returns empty string when no matches")
fun test_no_matches() {
    let test_file = "test_grep_nomatch.txt"
    let test_content = "Hello World\nThis is a test\nAnother line\n"
    fs_write(test_file, test_content)

    let result = grep_in_file("NOTFOUND", test_file)

    assert_eq(result, "", "Should return empty string when no matches")

    fs_remove_file(test_file)
}

@test("handles empty file")
fun test_empty_file() {
    let test_file = "test_grep_empty.txt"
    fs_write(test_file, "")

    let result = grep_in_file("pattern", test_file)

    assert_eq(result, "", "Should return empty string for empty file")

    fs_remove_file(test_file)
}

@test("finds pattern at line start")
fun test_pattern_at_start() {
    let test_file = "test_grep_start.txt"
    let test_content = "pattern at start\nmiddle pattern middle\nend pattern\n"
    fs_write(test_file, test_content)

    let result = grep_in_file("pattern", test_file)

    assert_eq(result, "pattern at start\nmiddle pattern middle\nend pattern\n", "Should find pattern anywhere in line")

    fs_remove_file(test_file)
}

@test("handles file without trailing newline")
fun test_no_trailing_newline() {
    let test_file = "test_grep_no_newline.txt"
    let test_content = "line one\nline two with pattern"
    fs_write(test_file, test_content)

    let result = grep_in_file("pattern", test_file)

    assert_eq(result, "line two with pattern\n", "Should handle last line without trailing newline")

    fs_remove_file(test_file)
}

// ============================================================================
// CASE-INSENSITIVE SEARCH TESTS
// ============================================================================

@test("case-insensitive search finds mixed case matches")
fun test_case_insensitive_search() {
    let test_file = "test_grep_case.txt"
    let test_content = "Hello World\nHELLO again\nhello there\nGoodbye\n"
    fs_write(test_file, test_content)

    let result = grep_in_file_ignore_case("hello", test_file)

    assert_eq(result, "Hello World\nHELLO again\nhello there\n", "Should find all case variations")

    fs_remove_file(test_file)
}

// ============================================================================
// PROPERTY-BASED TESTS - Invariants (200+ iterations)
// ============================================================================

@test("property: idempotent searches - same pattern always gives same result")
fun property_idempotent_search() {
    let test_file = "test_property_idempotent.txt"
    let test_content = "apple pie\nbanana split\napple juice\norange soda\napple crisp\n"
    fs_write(test_file, test_content)

    let first_result = grep_in_file("apple", test_file)

    // Property: Running same search 100 times should give same result
    for i in range(0, 100) {
        let current_result = grep_in_file("apple", test_file)
        assert_eq(current_result, first_result, "Grep should be idempotent - iteration " + i.to_string())
    }

    fs_remove_file(test_file)
}

@test("property: empty pattern matches all lines")
fun property_empty_pattern() {
    let test_file = "test_property_empty.txt"
    let test_content = "line one\nline two\nline three\n"
    fs_write(test_file, test_content)

    // Property: Empty pattern should match all lines (since every line contains "")
    let result = grep_in_file("", test_file)

    assert_eq(result, test_content, "Empty pattern should match all lines")

    fs_remove_file(test_file)
}

@test("property: result length never exceeds input length")
fun property_result_subset() {
    let test_file = "test_property_subset.txt"

    // Test with various file sizes
    for size in range(1, 50) {
        let test_content = ""
        for i in range(0, size) {
            test_content = test_content + "line" + i.to_string() + " data\n"
        }

        fs_write(test_file, test_content)
        let result = grep_in_file("data", test_file)

        // Property: Result length should be <= input length
        assert_eq(result.len() <= test_content.len(), true, "Result cannot be longer than input at size " + size.to_string())
    }

    fs_remove_file(test_file)
}
